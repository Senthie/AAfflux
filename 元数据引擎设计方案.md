# å…ƒæ•°æ®å¼•æ“è®¾è®¡æ–¹æ¡ˆ

## ğŸ“‹ æ–¹æ¡ˆæ¦‚è¿°

æœ¬æ–¹æ¡ˆæä¾›å®Œæ•´çš„å…ƒæ•°æ®é©±åŠ¨å¼•æ“è®¾è®¡ï¼ŒåŒ…æ‹¬å…ƒæ•°æ®æ¨¡å‹ã€è§£æå™¨ã€åŠ è½½å™¨ã€DDLç”Ÿæˆå™¨ã€åŠ¨æ€ORMå’ŒAPIç”Ÿæˆå™¨ã€‚

---

## ğŸ¯ è®¾è®¡ç›®æ ‡

### 1. æ ¸å¿ƒç›®æ ‡

- âœ… ç»Ÿä¸€çš„å…ƒæ•°æ®æ¨¡å‹å®šä¹‰
- âœ… å…ƒæ•°æ®çš„è§£æå’ŒåŠ è½½æœºåˆ¶
- âœ… æ ¹æ®å…ƒæ•°æ®åŠ¨æ€åˆ›å»ºæ•°æ®åº“è¡¨
- âœ… æ ¹æ®å…ƒæ•°æ®åŠ¨æ€ç”Ÿæˆ CRUD API
- âœ… æ”¯æŒå…ƒæ•°æ®ç‰ˆæœ¬æ§åˆ¶
- âœ… æ”¯æŒå…ƒæ•°æ®ç¼“å­˜å’Œçƒ­åŠ è½½

### 2. è®¾è®¡åŸåˆ™

- **é…ç½®ä¼˜äºä»£ç **ï¼šé€šè¿‡é…ç½®å®šä¹‰ä¸šåŠ¡æ¨¡å‹
- **çº¦å®šä¼˜äºé…ç½®**ï¼šæä¾›åˆç†çš„é»˜è®¤å€¼
- **æ¸è¿›å¼å¢å¼º**ï¼šæ”¯æŒä»ç®€å•åˆ°å¤æ‚çš„åœºæ™¯
- **å‘åå…¼å®¹**ï¼šä¸å½±å“ç°æœ‰ä»£ç é©±åŠ¨çš„æ¨¡å‹

---

## ğŸ—ï¸ æ•´ä½“æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Metadata Engine Architecture                â”‚
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚              Metadata Designer (å‰ç«¯)                 â”‚  â”‚
â”‚  â”‚  - æ•°æ®æ¨¡å‹è®¾è®¡å™¨                                     â”‚  â”‚
â”‚  â”‚  - å­—æ®µé…ç½®é¢æ¿                                       â”‚  â”‚
â”‚  â”‚  - å…³ç³»å®šä¹‰                                           â”‚  â”‚
â”‚  â”‚  - éªŒè¯è§„åˆ™é…ç½®                                       â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                          â†“                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚              Metadata Definition Layer                â”‚  â”‚
â”‚  â”‚  - MetadataModel (æ•°æ®æ¨¡å‹å…ƒæ•°æ®)                     â”‚  â”‚
â”‚  â”‚  - MetadataField (å­—æ®µå…ƒæ•°æ®)                         â”‚  â”‚
â”‚  â”‚  - MetadataRelation (å…³ç³»å…ƒæ•°æ®)                      â”‚  â”‚
â”‚  â”‚  - MetadataValidation (éªŒè¯è§„åˆ™)                      â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                          â†“                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚              Metadata Engine Core                     â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚  â”‚
â”‚  â”‚  â”‚ Parser     â”‚  â”‚ Loader     â”‚  â”‚ Cache      â”‚     â”‚  â”‚
â”‚  â”‚  â”‚ è§£æå™¨     â”‚  â”‚ åŠ è½½å™¨     â”‚  â”‚ ç¼“å­˜ç®¡ç†   â”‚     â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚  â”‚
â”‚  â”‚  â”‚ DDL        â”‚  â”‚ ORM        â”‚  â”‚ API        â”‚     â”‚  â”‚
â”‚  â”‚  â”‚ Generator  â”‚  â”‚ Generator  â”‚  â”‚ Generator  â”‚     â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                          â†“                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚              Runtime Layer                            â”‚  â”‚
â”‚  â”‚  - Dynamic Models (åŠ¨æ€æ¨¡å‹)                          â”‚  â”‚
â”‚  â”‚  - Generic CRUD Service (é€šç”¨CRUDæœåŠ¡)                â”‚  â”‚
â”‚  â”‚  - Dynamic API Routes (åŠ¨æ€APIè·¯ç”±)                   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                          â†“                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚              Data Layer                               â”‚  â”‚
â”‚  â”‚  - System Tables (ç³»ç»Ÿè¡¨ - 37å¼ )                      â”‚  â”‚
â”‚  â”‚  - Metadata Tables (å…ƒæ•°æ®è¡¨ - 6å¼ )                   â”‚  â”‚
â”‚  â”‚  - Dynamic Business Tables (åŠ¨æ€ä¸šåŠ¡è¡¨)               â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“Š å…ƒæ•°æ®æ¨¡å‹è®¾è®¡

### 1. æ ¸å¿ƒå…ƒæ•°æ®è¡¨

åˆ›å»º `api/app/models/metadata/model.py`ï¼š

```python
"""å…ƒæ•°æ®æ¨¡å‹å®šä¹‰"""

from datetime import datetime
from typing import Optional, List
from uuid import UUID, uuid4
from sqlmodel import Field, SQLModel, Column, JSON, Relationship
from enum import Enum


class ModelStatus(str, Enum):
    """æ¨¡å‹çŠ¶æ€"""
    DRAFT = "draft"          # è‰ç¨¿
    PUBLISHED = "published"  # å·²å‘å¸ƒ
    ARCHIVED = "archived"    # å·²å½’æ¡£


class FieldType(str, Enum):
    """å­—æ®µç±»å‹"""
    # åŸºæœ¬ç±»å‹
    STRING = "string"
    TEXT = "text"
    INTEGER = "integer"
    FLOAT = "float"
    DECIMAL = "decimal"
    BOOLEAN = "boolean"
    DATE = "date"
    DATETIME = "datetime"
    TIME = "time"
    
    # ç‰¹æ®Šç±»å‹
    EMAIL = "email"
    URL = "url"
    PHONE = "phone"
    JSON = "json"
    UUID = "uuid"
    
    # å…³ç³»ç±»å‹
    FOREIGN_KEY = "foreign_key"
    ONE_TO_MANY = "one_to_many"
    MANY_TO_MANY = "many_to_many"


class MetadataModel(SQLModel, table=True):
    """æ•°æ®æ¨¡å‹å…ƒæ•°æ®è¡¨"""
    
    __tablename__ = "metadata_models"
    
    # ä¸»é”®
    id: UUID = Field(default_factory=uuid4, primary_key=True)
    
    # ç§Ÿæˆ·éš”ç¦»
    workspace_id: UUID = Field(foreign_key="workspaces.id", index=True)
    
    # æ¨¡å‹ä¿¡æ¯
    name: str = Field(max_length=255, index=True)  # æ¨¡å‹åç§°ï¼ˆè‹±æ–‡ï¼Œå¦‚ customerï¼‰
    display_name: str = Field(max_length=255)  # æ˜¾ç¤ºåç§°ï¼ˆä¸­æ–‡ï¼Œå¦‚ å®¢æˆ·ï¼‰
    description: Optional[str] = Field(default=None)
    
    # æ•°æ®åº“ä¿¡æ¯
    table_name: str = Field(max_length=255)  # æ•°æ®åº“è¡¨å
    schema_name: Optional[str] = Field(default=None, max_length=255)  # æ•°æ®åº“æ¨¡å¼
    
    # æ¨¡å‹é…ç½®
    icon: Optional[str] = Field(default=None, max_length=255)  # å›¾æ ‡
    category: Optional[str] = Field(default=None, max_length=100)  # åˆ†ç±»
    
    # JSON Schema å®šä¹‰
    schema_definition: dict = Field(default_factory=dict, sa_column=Column(JSON))
    
    # ç‰ˆæœ¬æ§åˆ¶
    version: int = Field(default=1)
    is_latest: bool = Field(default=True)
    
    # çŠ¶æ€
    status: ModelStatus = Field(default=ModelStatus.DRAFT)
    
    # é…ç½®é€‰é¡¹
    enable_audit: bool = Field(default=True)  # å¯ç”¨å®¡è®¡å­—æ®µ
    enable_soft_delete: bool = Field(default=True)  # å¯ç”¨è½¯åˆ é™¤
    enable_versioning: bool = Field(default=False)  # å¯ç”¨ç‰ˆæœ¬æ§åˆ¶
    
    # æƒé™é…ç½®
    permissions: dict = Field(default_factory=dict, sa_column=Column(JSON))
    
    # å®¡è®¡å­—æ®µ
    created_by: UUID = Field(foreign_key="users.id")
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
    published_at: Optional[datetime] = Field(default=None)
    
    # å…³ç³»
    fields: List["MetadataField"] = Relationship(back_populates="model")


class MetadataField(SQLModel, table=True):
    """å­—æ®µå…ƒæ•°æ®è¡¨"""
    
    __tablename__ = "metadata_fields"
    
    # ä¸»é”®
    id: UUID = Field(default_factory=uuid4, primary_key=True)
    
    # æ‰€å±æ¨¡å‹
    model_id: UUID = Field(foreign_key="metadata_models.id", index=True)
    
    # å­—æ®µä¿¡æ¯
    name: str = Field(max_length=255)  # å­—æ®µåç§°ï¼ˆè‹±æ–‡ï¼‰
    display_name: str = Field(max_length=255)  # æ˜¾ç¤ºåç§°ï¼ˆä¸­æ–‡ï¼‰
    description: Optional[str] = Field(default=None)
    
    # å­—æ®µç±»å‹
    field_type: FieldType  # é€»è¾‘ç±»å‹
    db_type: str = Field(max_length=50)  # æ•°æ®åº“ç±»å‹ï¼ˆå¦‚ VARCHAR(255)ï¼‰
    
    # å­—æ®µå±æ€§
    is_required: bool = Field(default=False)  # å¿…å¡«
    is_unique: bool = Field(default=False)  # å”¯ä¸€
    is_indexed: bool = Field(default=False)  # ç´¢å¼•
    is_primary_key: bool = Field(default=False)  # ä¸»é”®
    
    # é»˜è®¤å€¼
    default_value: Optional[str] = Field(default=None)
    
    # éªŒè¯è§„åˆ™
    validation_rules: dict = Field(default_factory=dict, sa_column=Column(JSON))
    # ç¤ºä¾‹ï¼š
    # {
    #   "min_length": 2,
    #   "max_length": 100,
    #   "pattern": "^[a-zA-Z]+$",
    #   "min": 0,
    #   "max": 100,
    #   "enum": ["active", "inactive"]
    # }
    
    # UI é…ç½®
    ui_config: dict = Field(default_factory=dict, sa_column=Column(JSON))
    # ç¤ºä¾‹ï¼š
    # {
    #   "widget": "input",  # input, textarea, select, date-picker, etc.
    #   "placeholder": "è¯·è¾“å…¥å®¢æˆ·åç§°",
    #   "help_text": "å®¢æˆ·çš„å…¨ç§°",
    #   "width": "100%"
    # }
    
    # å…³ç³»é…ç½®ï¼ˆç”¨äºå¤–é”®å­—æ®µï¼‰
    relation_config: Optional[dict] = Field(default=None, sa_column=Column(JSON))
    # ç¤ºä¾‹ï¼š
    # {
    #   "target_model": "user",
    #   "relation_type": "many_to_one",
    #   "on_delete": "CASCADE"
    # }
    
    # æ˜¾ç¤ºé¡ºåº
    position: int = Field(default=0)
    
    # å®¡è®¡å­—æ®µ
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
    
    # å…³ç³»
    model: MetadataModel = Relationship(back_populates="fields")


class MetadataRelation(SQLModel, table=True):
    """å…³ç³»å…ƒæ•°æ®è¡¨"""
    
    __tablename__ = "metadata_relations"
    
    # ä¸»é”®
    id: UUID = Field(default_factory=uuid4, primary_key=True)
    
    # æºæ¨¡å‹å’Œç›®æ ‡æ¨¡å‹
    source_model_id: UUID = Field(foreign_key="metadata_models.id")
    target_model_id: UUID = Field(foreign_key="metadata_models.id")
    
    # å…³ç³»ä¿¡æ¯
    name: str = Field(max_length=255)  # å…³ç³»åç§°
    relation_type: str = Field(max_length=50)  # one_to_one, one_to_many, many_to_many
    
    # å¤–é”®å­—æ®µ
    foreign_key_field: str = Field(max_length=255)  # å¤–é”®å­—æ®µå
    
    # çº§è”æ“ä½œ
    on_delete: str = Field(default="CASCADE", max_length=50)  # CASCADE, SET_NULL, RESTRICT
    on_update: str = Field(default="CASCADE", max_length=50)
    
    # ä¸­é—´è¡¨ï¼ˆç”¨äºå¤šå¯¹å¤šï¼‰
    junction_table: Optional[str] = Field(default=None, max_length=255)
    
    # å®¡è®¡å­—æ®µ
    created_at: datetime = Field(default_factory=datetime.utcnow)


class MetadataIndex(SQLModel, table=True):
    """ç´¢å¼•å…ƒæ•°æ®è¡¨"""
    
    __tablename__ = "metadata_indexes"
    
    # ä¸»é”®
    id: UUID = Field(default_factory=uuid4, primary_key=True)
    
    # æ‰€å±æ¨¡å‹
    model_id: UUID = Field(foreign_key="metadata_models.id")
    
    # ç´¢å¼•ä¿¡æ¯
    name: str = Field(max_length=255)  # ç´¢å¼•åç§°
    fields: List[str] = Field(sa_column=Column(JSON))  # ç´¢å¼•å­—æ®µåˆ—è¡¨
    is_unique: bool = Field(default=False)  # æ˜¯å¦å”¯ä¸€ç´¢å¼•
    
    # å®¡è®¡å­—æ®µ
    created_at: datetime = Field(default_factory=datetime.utcnow)


class MetadataVersion(SQLModel, table=True):
    """å…ƒæ•°æ®ç‰ˆæœ¬è¡¨"""
    
    __tablename__ = "metadata_versions"
    
    # ä¸»é”®
    id: UUID = Field(default_factory=uuid4, primary_key=True)
    
    # å®ä½“ä¿¡æ¯
    entity_type: str = Field(max_length=50)  # model, field, relation
    entity_id: UUID  # å®ä½“ID
    
    # ç‰ˆæœ¬ä¿¡æ¯
    version: int
    content: dict = Field(sa_column=Column(JSON))  # ç‰ˆæœ¬å†…å®¹å¿«ç…§
    change_log: Optional[str] = Field(default=None)  # å˜æ›´æ—¥å¿—
    
    # å®¡è®¡å­—æ®µ
    created_by: UUID = Field(foreign_key="users.id")
    created_at: datetime = Field(default_factory=datetime.utcnow)


class MetadataPage(SQLModel, table=True):
    """é¡µé¢å…ƒæ•°æ®è¡¨"""
    
    __tablename__ = "metadata_pages"
    
    # ä¸»é”®
    id: UUID = Field(default_factory=uuid4, primary_key=True)
    
    # ç§Ÿæˆ·éš”ç¦»
    workspace_id: UUID = Field(foreign_key="workspaces.id", index=True)
    
    # é¡µé¢ä¿¡æ¯
    name: str = Field(max_length=255, index=True)
    display_name: str = Field(max_length=255)
    description: Optional[str] = Field(default=None)
    
    # è·¯ç”±ä¿¡æ¯
    route_path: str = Field(max_length=500)  # è·¯ç”±è·¯å¾„
    
    # å¸ƒå±€é…ç½®
    layout_config: dict = Field(default_factory=dict, sa_column=Column(JSON))
    
    # ç»„ä»¶é…ç½®
    components: List[dict] = Field(default_factory=list, sa_column=Column(JSON))
    
    # æ•°æ®ç»‘å®š
    data_binding: dict = Field(default_factory=dict, sa_column=Column(JSON))
    
    # æƒé™é…ç½®
    permissions: dict = Field(default_factory=dict, sa_column=Column(JSON))
    
    # ç‰ˆæœ¬æ§åˆ¶
    version: int = Field(default=1)
    status: str = Field(max_length=50, default="draft")
    
    # å®¡è®¡å­—æ®µ
    created_by: UUID = Field(foreign_key="users.id")
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
```

---

## ğŸ”§ æ ¸å¿ƒç»„ä»¶å®ç°

### 1. DDL ç”Ÿæˆå™¨

åˆ›å»º `api/app/engine/metadata/ddl_generator.py`ï¼š

```python
"""DDL ç”Ÿæˆå™¨ - æ ¹æ®å…ƒæ•°æ®ç”Ÿæˆæ•°æ®åº“è¡¨"""

from typing import List, Dict, Any
from uuid import UUID
from sqlmodel import select
from sqlmodel.ext.asyncio.session import AsyncSession

from app.models.metadata import MetadataModel, MetadataField, FieldType
from app.core.logging import get_logger

logger = get_logger(__name__)


class DDLGenerator:
    """DDL ç”Ÿæˆå™¨"""
    
    # å­—æ®µç±»å‹æ˜ å°„
    TYPE_MAPPING = {
        FieldType.STRING: "VARCHAR(255)",
        FieldType.TEXT: "TEXT",
        FieldType.INTEGER: "INTEGER",
        FieldType.FLOAT: "FLOAT",
        FieldType.DECIMAL: "DECIMAL(10,2)",
        FieldType.BOOLEAN: "BOOLEAN",
        FieldType.DATE: "DATE",
        FieldType.DATETIME: "TIMESTAMP",
        FieldType.TIME: "TIME",
        FieldType.EMAIL: "VARCHAR(255)",
        FieldType.URL: "VARCHAR(500)",
        FieldType.PHONE: "VARCHAR(50)",
        FieldType.JSON: "JSONB",
        FieldType.UUID: "UUID",
        FieldType.FOREIGN_KEY: "UUID",
    }
    
    def __init__(self, session: AsyncSession):
        self.session = session
    
    async def generate_create_table(
        self,
        model_id: UUID
    ) -> str:
        """
        ç”Ÿæˆ CREATE TABLE è¯­å¥
        
        Args:
            model_id: æ¨¡å‹ID
        
        Returns:
            CREATE TABLE SQL è¯­å¥
        """
        # 1. è·å–æ¨¡å‹å…ƒæ•°æ®
        result = await self.session.execute(
            select(MetadataModel).where(MetadataModel.id == model_id)
        )
        model = result.scalar_one_or_none()
        if not model:
            raise ValueError(f"Model not found: {model_id}")
        
        # 2. è·å–å­—æ®µå…ƒæ•°æ®
        result = await self.session.execute(
            select(MetadataField)
            .where(MetadataField.model_id == model_id)
            .order_by(MetadataField.position)
        )
        fields = result.scalars().all()
        
        # 3. ç”Ÿæˆè¡¨åï¼ˆå¸¦ç§Ÿæˆ·å‰ç¼€ï¼‰
        table_name = f"tenant_{model.workspace_id}_{model.table_name}"
        
        # 4. ç”Ÿæˆå­—æ®µå®šä¹‰
        field_definitions = []
        
        # æ·»åŠ ä¸»é”®ï¼ˆå¦‚æœæ²¡æœ‰è‡ªå®šä¹‰ä¸»é”®ï¼‰
        has_primary_key = any(f.is_primary_key for f in fields)
        if not has_primary_key:
            field_definitions.append("id UUID PRIMARY KEY DEFAULT gen_random_uuid()")
        
        # æ·»åŠ ç§Ÿæˆ·éš”ç¦»å­—æ®µ
        field_definitions.append(
            f"workspace_id UUID NOT NULL REFERENCES workspaces(id)"
        )
        
        # æ·»åŠ ä¸šåŠ¡å­—æ®µ
        for field in fields:
            field_def = self._generate_field_definition(field)
            field_definitions.append(field_def)
        
        # æ·»åŠ å®¡è®¡å­—æ®µï¼ˆå¦‚æœå¯ç”¨ï¼‰
        if model.enable_audit:
            field_definitions.extend([
                "created_by UUID REFERENCES users(id)",
                "created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP",
                "updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP"
            ])
        
        # æ·»åŠ è½¯åˆ é™¤å­—æ®µï¼ˆå¦‚æœå¯ç”¨ï¼‰
        if model.enable_soft_delete:
            field_definitions.extend([
                "deleted_at TIMESTAMP",
                "deleted_by UUID REFERENCES users(id)"
            ])
        
        # 5. ç”Ÿæˆ CREATE TABLE è¯­å¥
        sql = f"""
CREATE TABLE IF NOT EXISTS {table_name} (
    {',\n    '.join(field_definitions)}
);
"""
        
        # 6. ç”Ÿæˆç´¢å¼•
        index_sqls = self._generate_indexes(table_name, model, fields)
        
        return sql + '\n' + '\n'.join(index_sqls)
    
    def _generate_field_definition(self, field: MetadataField) -> str:
        """ç”Ÿæˆå­—æ®µå®šä¹‰"""
        parts = [field.name]
        
        # æ•°æ®ç±»å‹
        if field.db_type:
            parts.append(field.db_type)
        else:
            parts.append(self.TYPE_MAPPING.get(field.field_type, "VARCHAR(255)"))
        
        # çº¦æŸ
        if field.is_required:
            parts.append("NOT NULL")
        
        if field.is_unique:
            parts.append("UNIQUE")
        
        if field.default_value:
            parts.append(f"DEFAULT {field.default_value}")
        
        # å¤–é”®
        if field.field_type == FieldType.FOREIGN_KEY and field.relation_config:
            target_model = field.relation_config.get('target_model')
            on_delete = field.relation_config.get('on_delete', 'CASCADE')
            parts.append(f"REFERENCES {target_model}(id) ON DELETE {on_delete}")
        
        return ' '.join(parts)
    
    def _generate_indexes(
        self,
        table_name: str,
        model: MetadataModel,
        fields: List[MetadataField]
    ) -> List[str]:
        """ç”Ÿæˆç´¢å¼•è¯­å¥"""
        indexes = []
        
        # ç§Ÿæˆ·éš”ç¦»ç´¢å¼•
        indexes.append(
            f"CREATE INDEX IF NOT EXISTS idx_{table_name}_workspace "
            f"ON {table_name}(workspace_id);"
        )
        
        # å­—æ®µç´¢å¼•
        for field in fields:
            if field.is_indexed:
                index_name = f"idx_{table_name}_{field.name}"
                indexes.append(
                    f"CREATE INDEX IF NOT EXISTS {index_name} "
                    f"ON {table_name}({field.name});"
                )
        
        # è½¯åˆ é™¤ç´¢å¼•
        if model.enable_soft_delete:
            indexes.append(
                f"CREATE INDEX IF NOT EXISTS idx_{table_name}_deleted "
                f"ON {table_name}(deleted_at) WHERE deleted_at IS NULL;"
            )
        
        return indexes
    
    async def generate_alter_table(
        self,
        model_id: UUID,
        old_fields: List[MetadataField],
        new_fields: List[MetadataField]
    ) -> List[str]:
        """
        ç”Ÿæˆ ALTER TABLE è¯­å¥
        
        Args:
            model_id: æ¨¡å‹ID
            old_fields: æ—§å­—æ®µåˆ—è¡¨
            new_fields: æ–°å­—æ®µåˆ—è¡¨
        
        Returns:
            ALTER TABLE SQL è¯­å¥åˆ—è¡¨
        """
        # è·å–æ¨¡å‹
        result = await self.session.execute(
            select(MetadataModel).where(MetadataModel.id == model_id)
        )
        model = result.scalar_one_or_none()
        if not model:
            raise ValueError(f"Model not found: {model_id}")
        
        table_name = f"tenant_{model.workspace_id}_{model.table_name}"
        
        sqls = []
        
        # 1. æ‰¾å‡ºæ–°å¢çš„å­—æ®µ
        old_field_names = {f.name for f in old_fields}
        new_field_names = {f.name for f in new_fields}
        
        added_fields = [f for f in new_fields if f.name not in old_field_names]
        removed_fields = [f for f in old_fields if f.name not in new_field_names]
        
        # 2. ç”Ÿæˆ ADD COLUMN è¯­å¥
        for field in added_fields:
            field_def = self._generate_field_definition(field)
            sqls.append(
                f"ALTER TABLE {table_name} ADD COLUMN {field_def};"
            )
        
        # 3. ç”Ÿæˆ DROP COLUMN è¯­å¥ï¼ˆè°¨æ…ä½¿ç”¨ï¼‰
        for field in removed_fields:
            sqls.append(
                f"ALTER TABLE {table_name} DROP COLUMN IF EXISTS {field.name};"
            )
        
        # 4. æ£€æŸ¥ä¿®æ”¹çš„å­—æ®µ
        common_fields = old_field_names & new_field_names
        for field_name in common_fields:
            old_field = next(f for f in old_fields if f.name == field_name)
            new_field = next(f for f in new_fields if f.name == field_name)
            
            # æ£€æŸ¥ç±»å‹æ˜¯å¦å˜åŒ–
            if old_field.db_type != new_field.db_type:
                sqls.append(
                    f"ALTER TABLE {table_name} "
                    f"ALTER COLUMN {field_name} TYPE {new_field.db_type};"
                )
            
            # æ£€æŸ¥ NOT NULL çº¦æŸ
            if old_field.is_required != new_field.is_required:
                if new_field.is_required:
                    sqls.append(
                        f"ALTER TABLE {table_name} "
                        f"ALTER COLUMN {field_name} SET NOT NULL;"
                    )
                else:
                    sqls.append(
                        f"ALTER TABLE {table_name} "
                        f"ALTER COLUMN {field_name} DROP NOT NULL;"
                    )
        
        return sqls
    
    async def execute_ddl(self, sql: str) -> None:
        """æ‰§è¡Œ DDL è¯­å¥"""
        try:
            await self.session.execute(sql)
            await self.session.commit()
            logger.info("DDL executed successfully", sql=sql[:100])
        except Exception as e:
            await self.session.rollback()
            logger.error("Failed to execute DDL", sql=sql[:100], error=str(e))
            raise


### 2. åŠ¨æ€ ORM ç”Ÿæˆå™¨

åˆ›å»º `api/app/engine/metadata/orm_generator.py`ï¼š

```python
"""åŠ¨æ€ ORM ç”Ÿæˆå™¨ - æ ¹æ®å…ƒæ•°æ®ç”Ÿæˆ SQLModel ç±»"""

from typing import Type, Dict, Any, Optional
from uuid import UUID
from datetime import datetime
from sqlmodel import Field, SQLModel, Column, JSON
from sqlmodel import select
from sqlmodel.ext.asyncio.session import AsyncSession

from app.models.metadata import MetadataModel, MetadataField, FieldType
from app.core.logging import get_logger

logger = get_logger(__name__)


class DynamicModelGenerator:
    """åŠ¨æ€æ¨¡å‹ç”Ÿæˆå™¨"""
    
    # ç±»å‹æ˜ å°„
    PYTHON_TYPE_MAPPING = {
        FieldType.STRING: str,
        FieldType.TEXT: str,
        FieldType.INTEGER: int,
        FieldType.FLOAT: float,
        FieldType.DECIMAL: float,
        FieldType.BOOLEAN: bool,
        FieldType.DATE: datetime,
        FieldType.DATETIME: datetime,
        FieldType.TIME: datetime,
        FieldType.EMAIL: str,
        FieldType.URL: str,
        FieldType.PHONE: str,
        FieldType.JSON: dict,
        FieldType.UUID: UUID,
        FieldType.FOREIGN_KEY: UUID,
    }
    
    def __init__(self, session: AsyncSession):
        self.session = session
        self._model_cache: Dict[str, Type[SQLModel]] = {}
    
    async def generate_model(
        self,
        model_id: UUID,
        use_cache: bool = True
    ) -> Type[SQLModel]:
        """
        ç”ŸæˆåŠ¨æ€æ¨¡å‹ç±»
        
        Args:
            model_id: æ¨¡å‹ID
            use_cache: æ˜¯å¦ä½¿ç”¨ç¼“å­˜
        
        Returns:
            åŠ¨æ€ç”Ÿæˆçš„ SQLModel ç±»
        """
        # 1. æ£€æŸ¥ç¼“å­˜
        cache_key = str(model_id)
        if use_cache and cache_key in self._model_cache:
            return self._model_cache[cache_key]
        
        # 2. è·å–æ¨¡å‹å…ƒæ•°æ®
        result = await self.session.execute(
            select(MetadataModel).where(MetadataModel.id == model_id)
        )
        model_meta = result.scalar_one_or_none()
        if not model_meta:
            raise ValueError(f"Model not found: {model_id}")
        
        # 3. è·å–å­—æ®µå…ƒæ•°æ®
        result = await self.session.execute(
            select(MetadataField)
            .where(MetadataField.model_id == model_id)
            .order_by(MetadataField.position)
        )
        fields = result.scalars().all()
        
        # 4. ç”Ÿæˆå­—æ®µå®šä¹‰
        field_definitions = {}
        
        # ä¸»é”®
        field_definitions['id'] = (
            UUID,
            Field(default_factory=uuid4, primary_key=True)
        )
        
        # ç§Ÿæˆ·éš”ç¦»
        field_definitions['workspace_id'] = (
            UUID,
            Field(foreign_key="workspaces.id", index=True)
        )
        
        # ä¸šåŠ¡å­—æ®µ
        for field in fields:
            field_def = self._generate_field_definition(field)
            field_definitions[field.name] = field_def
        
        # å®¡è®¡å­—æ®µ
        if model_meta.enable_audit:
            field_definitions['created_by'] = (
                UUID,
                Field(foreign_key="users.id")
            )
            field_definitions['created_at'] = (
                datetime,
                Field(default_factory=datetime.utcnow)
            )
            field_definitions['updated_at'] = (
                datetime,
                Field(default_factory=datetime.utcnow)
            )
        
        # è½¯åˆ é™¤å­—æ®µ
        if model_meta.enable_soft_delete:
            field_definitions['deleted_at'] = (
                Optional[datetime],
                Field(default=None)
            )
            field_definitions['deleted_by'] = (
                Optional[UUID],
                Field(default=None, foreign_key="users.id")
            )
        
        # 5. ç”Ÿæˆè¡¨å
        table_name = f"tenant_{model_meta.workspace_id}_{model_meta.table_name}"
        
        # 6. åŠ¨æ€åˆ›å»ºç±»
        model_class = type(
            model_meta.name.capitalize(),  # ç±»å
            (SQLModel,),  # åŸºç±»
            {
                '__tablename__': table_name,
                '__table_args__': {'extend_existing': True},
                **field_definitions
            }
        )
        
        # 7. ç¼“å­˜æ¨¡å‹
        self._model_cache[cache_key] = model_class
        
        logger.info(
            "Dynamic model generated",
            model_name=model_meta.name,
            table_name=table_name
        )
        
        return model_class
    
    def _generate_field_definition(
        self,
        field: MetadataField
    ) -> tuple:
        """ç”Ÿæˆå­—æ®µå®šä¹‰"""
        # Python ç±»å‹
        python_type = self.PYTHON_TYPE_MAPPING.get(
            field.field_type,
            str
        )
        
        # å¦‚æœä¸æ˜¯å¿…å¡«ï¼Œä½¿ç”¨ Optional
        if not field.is_required:
            python_type = Optional[python_type]
        
        # Field é…ç½®
        field_kwargs = {}
        
        if field.is_unique:
            field_kwargs['unique'] = True
        
        if field.is_indexed:
            field_kwargs['index'] = True
        
        if field.default_value:
            field_kwargs['default'] = field.default_value
        
        if field.field_type == FieldType.FOREIGN_KEY and field.relation_config:
            target_model = field.relation_config.get('target_model')
            field_kwargs['foreign_key'] = f"{target_model}.id"
        
        if field.field_type == FieldType.JSON:
            field_kwargs['sa_column'] = Column(JSON)
        
        return (python_type, Field(**field_kwargs))
    
    def clear_cache(self):
        """æ¸…ç©ºç¼“å­˜"""
        self._model_cache.clear()


### 3. é€šç”¨ CRUD æœåŠ¡

åˆ›å»º `api/app/services/generic_crud_service.py`ï¼š

```python
"""é€šç”¨ CRUD æœåŠ¡ - åŸºäºå…ƒæ•°æ®çš„åŠ¨æ€ CRUD"""

from typing import List, Dict, Any, Optional
from uuid import UUID
from sqlmodel import select, func
from sqlmodel.ext.asyncio.session import AsyncSession

from app.engine.metadata.orm_generator import DynamicModelGenerator
from app.core.logging import get_logger

logger = get_logger(__name__)


class GenericCRUDService:
    """é€šç”¨ CRUD æœåŠ¡"""
    
    def __init__(self, session: AsyncSession):
        self.session = session
        self.model_generator = DynamicModelGenerator(session)
    
    async def create(
        self,
        model_id: UUID,
        data: Dict[str, Any],
        workspace_id: UUID,
        created_by: UUID
    ) -> Dict[str, Any]:
        """
        åˆ›å»ºè®°å½•
        
        Args:
            model_id: æ¨¡å‹ID
            data: æ•°æ®
            workspace_id: å·¥ä½œç©ºé—´ID
            created_by: åˆ›å»ºè€…ID
        
        Returns:
            åˆ›å»ºçš„è®°å½•
        """
        # 1. ç”ŸæˆåŠ¨æ€æ¨¡å‹
        model_class = await self.model_generator.generate_model(model_id)
        
        # 2. æ·»åŠ ç³»ç»Ÿå­—æ®µ
        data['workspace_id'] = workspace_id
        data['created_by'] = created_by
        
        # 3. åˆ›å»ºå®ä¾‹
        instance = model_class(**data)
        
        # 4. ä¿å­˜åˆ°æ•°æ®åº“
        self.session.add(instance)
        await self.session.commit()
        await self.session.refresh(instance)
        
        logger.info(
            "Record created",
            model_id=str(model_id),
            record_id=str(instance.id)
        )
        
        return instance.dict()
    
    async def get(
        self,
        model_id: UUID,
        record_id: UUID,
        workspace_id: UUID
    ) -> Optional[Dict[str, Any]]:
        """è·å–å•æ¡è®°å½•"""
        # 1. ç”ŸæˆåŠ¨æ€æ¨¡å‹
        model_class = await self.model_generator.generate_model(model_id)
        
        # 2. æŸ¥è¯¢
        result = await self.session.execute(
            select(model_class).where(
                model_class.id == record_id,
                model_class.workspace_id == workspace_id
            )
        )
        instance = result.scalar_one_or_none()
        
        if instance:
            return instance.dict()
        return None
    
    async def list(
        self,
        model_id: UUID,
        workspace_id: UUID,
        filters: Optional[Dict[str, Any]] = None,
        page: int = 1,
        page_size: int = 20,
        order_by: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        æŸ¥è¯¢è®°å½•åˆ—è¡¨
        
        Args:
            model_id: æ¨¡å‹ID
            workspace_id: å·¥ä½œç©ºé—´ID
            filters: è¿‡æ»¤æ¡ä»¶
            page: é¡µç 
            page_size: æ¯é¡µæ•°é‡
            order_by: æ’åºå­—æ®µ
        
        Returns:
            åˆ†é¡µç»“æœ
        """
        # 1. ç”ŸæˆåŠ¨æ€æ¨¡å‹
        model_class = await self.model_generator.generate_model(model_id)
        
        # 2. æ„å»ºæŸ¥è¯¢
        query = select(model_class).where(
            model_class.workspace_id == workspace_id
        )
        
        # 3. åº”ç”¨è¿‡æ»¤æ¡ä»¶
        if filters:
            for key, value in filters.items():
                if hasattr(model_class, key):
                    query = query.where(getattr(model_class, key) == value)
        
        # 4. æ’åº
        if order_by:
            if order_by.startswith('-'):
                # é™åº
                field = order_by[1:]
                if hasattr(model_class, field):
                    query = query.order_by(getattr(model_class, field).desc())
            else:
                # å‡åº
                if hasattr(model_class, order_by):
                    query = query.order_by(getattr(model_class, order_by))
        
        # 5. åˆ†é¡µ
        offset = (page - 1) * page_size
        query = query.offset(offset).limit(page_size)
        
        # 6. æ‰§è¡ŒæŸ¥è¯¢
        result = await self.session.execute(query)
        instances = result.scalars().all()
        
        # 7. ç»Ÿè®¡æ€»æ•°
        count_query = select(func.count()).select_from(model_class).where(
            model_class.workspace_id == workspace_id
        )
        if filters:
            for key, value in filters.items():
                if hasattr(model_class, key):
                    count_query = count_query.where(
                        getattr(model_class, key) == value
                    )
        
        total_result = await self.session.execute(count_query)
        total = total_result.scalar()
        
        return {
            'items': [instance.dict() for instance in instances],
            'total': total,
            'page': page,
            'page_size': page_size,
            'pages': (total + page_size - 1) // page_size
        }
    
    async def update(
        self,
        model_id: UUID,
        record_id: UUID,
        data: Dict[str, Any],
        workspace_id: UUID
    ) -> Optional[Dict[str, Any]]:
        """æ›´æ–°è®°å½•"""
        # 1. ç”ŸæˆåŠ¨æ€æ¨¡å‹
        model_class = await self.model_generator.generate_model(model_id)
        
        # 2. æŸ¥è¯¢è®°å½•
        result = await self.session.execute(
            select(model_class).where(
                model_class.id == record_id,
                model_class.workspace_id == workspace_id
            )
        )
        instance = result.scalar_one_or_none()
        
        if not instance:
            return None
        
        # 3. æ›´æ–°å­—æ®µ
        for key, value in data.items():
            if hasattr(instance, key):
                setattr(instance, key, value)
        
        # 4. æ›´æ–°æ—¶é—´æˆ³
        if hasattr(instance, 'updated_at'):
            instance.updated_at = datetime.utcnow()
        
        # 5. ä¿å­˜
        self.session.add(instance)
        await self.session.commit()
        await self.session.refresh(instance)
        
        logger.info(
            "Record updated",
            model_id=str(model_id),
            record_id=str(record_id)
        )
        
        return instance.dict()
    
    async def delete(
        self,
        model_id: UUID,
        record_id: UUID,
        workspace_id: UUID,
        soft_delete: bool = True
    ) -> bool:
        """åˆ é™¤è®°å½•"""
        # 1. ç”ŸæˆåŠ¨æ€æ¨¡å‹
        model_class = await self.model_generator.generate_model(model_id)
        
        # 2. æŸ¥è¯¢è®°å½•
        result = await self.session.execute(
            select(model_class).where(
                model_class.id == record_id,
                model_class.workspace_id == workspace_id
            )
        )
        instance = result.scalar_one_or_none()
        
        if not instance:
            return False
        
        # 3. åˆ é™¤
        if soft_delete and hasattr(instance, 'deleted_at'):
            # è½¯åˆ é™¤
            instance.deleted_at = datetime.utcnow()
            self.session.add(instance)
        else:
            # ç¡¬åˆ é™¤
            await self.session.delete(instance)
        
        await self.session.commit()
        
        logger.info(
            "Record deleted",
            model_id=str(model_id),
            record_id=str(record_id),
            soft_delete=soft_delete
        )
        
        return True
```

---

### 4. åŠ¨æ€ API ç”Ÿæˆå™¨

åˆ›å»º `api/app/engine/metadata/api_generator.py`ï¼š

```python
"""åŠ¨æ€ API ç”Ÿæˆå™¨ - æ ¹æ®å…ƒæ•°æ®ç”Ÿæˆ REST API"""

from typing import Dict, Any
from uuid import UUID
from fastapi import APIRouter, Depends, HTTPException, Query
from pydantic import BaseModel, create_model
from sqlmodel.ext.asyncio.session import AsyncSession

from app.core.database import get_session
from app.services.generic_crud_service import GenericCRUDService
from app.core.logging import get_logger

logger = get_logger(__name__)


class DynamicAPIGenerator:
    """åŠ¨æ€ API ç”Ÿæˆå™¨"""
    
    def __init__(self):
        self.routers: Dict[str, APIRouter] = {}
    
    def generate_crud_router(
        self,
        model_id: UUID,
        model_name: str,
        tags: list = None
    ) -> APIRouter:
        """
        ç”Ÿæˆ CRUD API è·¯ç”±
        
        Args:
            model_id: æ¨¡å‹ID
            model_name: æ¨¡å‹åç§°
            tags: API æ ‡ç­¾
        
        Returns:
            FastAPI Router
        """
        router = APIRouter(
            prefix=f"/data/{model_name}",
            tags=tags or [f"Dynamic - {model_name}"]
        )
        
        # åˆ›å»º Pydantic æ¨¡å‹ï¼ˆç”¨äºè¯·æ±‚éªŒè¯ï¼‰
        CreateSchema = self._create_schema(f"{model_name}Create")
        UpdateSchema = self._create_schema(f"{model_name}Update")
        
        # ==================== CREATE ====================
        @router.post("", response_model=Dict[str, Any])
        async def create_record(
            data: CreateSchema,
            workspace_id: UUID = Query(...),
            user_id: UUID = Query(...),  # å®é™…åº”ä»è®¤è¯ä¸­è·å–
            session: AsyncSession = Depends(get_session)
        ):
            """åˆ›å»ºè®°å½•"""
            service = GenericCRUDService(session)
            return await service.create(
                model_id=model_id,
                data=data.dict(),
                workspace_id=workspace_id,
                created_by=user_id
            )
        
        # ==================== READ ====================
        @router.get("/{record_id}", response_model=Dict[str, Any])
        async def get_record(
            record_id: UUID,
            workspace_id: UUID = Query(...),
            session: AsyncSession = Depends(get_session)
        ):
            """è·å–å•æ¡è®°å½•"""
            service = GenericCRUDService(session)
            record = await service.get(
                model_id=model_id,
                record_id=record_id,
                workspace_id=workspace_id
            )
            if not record:
                raise HTTPException(status_code=404, detail="Record not found")
            return record
        
        @router.get("", response_model=Dict[str, Any])
        async def list_records(
            workspace_id: UUID = Query(...),
            page: int = Query(1, ge=1),
            page_size: int = Query(20, ge=1, le=100),
            order_by: str = Query(None),
            session: AsyncSession = Depends(get_session)
        ):
            """æŸ¥è¯¢è®°å½•åˆ—è¡¨"""
            service = GenericCRUDService(session)
            return await service.list(
                model_id=model_id,
                workspace_id=workspace_id,
                page=page,
                page_size=page_size,
                order_by=order_by
            )
        
        # ==================== UPDATE ====================
        @router.put("/{record_id}", response_model=Dict[str, Any])
        async def update_record(
            record_id: UUID,
            data: UpdateSchema,
            workspace_id: UUID = Query(...),
            session: AsyncSession = Depends(get_session)
        ):
            """æ›´æ–°è®°å½•"""
            service = GenericCRUDService(session)
            record = await service.update(
                model_id=model_id,
                record_id=record_id,
                data=data.dict(exclude_unset=True),
                workspace_id=workspace_id
            )
            if not record:
                raise HTTPException(status_code=404, detail="Record not found")
            return record
        
        # ==================== DELETE ====================
        @router.delete("/{record_id}")
        async def delete_record(
            record_id: UUID,
            workspace_id: UUID = Query(...),
            hard_delete: bool = Query(False),
            session: AsyncSession = Depends(get_session)
        ):
            """åˆ é™¤è®°å½•"""
            service = GenericCRUDService(session)
            success = await service.delete(
                model_id=model_id,
                record_id=record_id,
                workspace_id=workspace_id,
                soft_delete=not hard_delete
            )
            if not success:
                raise HTTPException(status_code=404, detail="Record not found")
            return {"message": "Record deleted successfully"}
        
        # ç¼“å­˜è·¯ç”±
        self.routers[model_name] = router
        
        logger.info(
            "Dynamic API router generated",
            model_name=model_name,
            model_id=str(model_id)
        )
        
        return router
    
    def _create_schema(self, schema_name: str) -> type[BaseModel]:
        """åˆ›å»ºåŠ¨æ€ Pydantic Schema"""
        # è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…åº”æ ¹æ®å…ƒæ•°æ®å­—æ®µç”Ÿæˆ
        return create_model(
            schema_name,
            __base__=BaseModel,
            **{'data': (Dict[str, Any], ...)}
        )


## ğŸ“ ä½¿ç”¨ç¤ºä¾‹

### ç¤ºä¾‹1ï¼šåˆ›å»ºæ•°æ®æ¨¡å‹

```python
from app.services.metadata_service import MetadataService

# 1. å®šä¹‰æ•°æ®æ¨¡å‹
model_data = {
    "name": "customer",
    "display_name": "å®¢æˆ·",
    "description": "å®¢æˆ·ä¿¡æ¯ç®¡ç†",
    "table_name": "customers",
    "enable_audit": True,
    "enable_soft_delete": True,
    "fields": [
        {
            "name": "name",
            "display_name": "å®¢æˆ·åç§°",
            "field_type": "string",
            "is_required": True,
            "validation_rules": {
                "min_length": 2,
                "max_length": 100
            },
            "ui_config": {
                "widget": "input",
                "placeholder": "è¯·è¾“å…¥å®¢æˆ·åç§°"
            }
        },
        {
            "name": "email",
            "display_name": "é‚®ç®±",
            "field_type": "email",
            "is_required": True,
            "is_unique": True,
            "validation_rules": {
                "pattern": "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$"
            }
        },
        {
            "name": "phone",
            "display_name": "ç”µè¯",
            "field_type": "phone",
            "validation_rules": {
                "pattern": "^1[3-9]\\d{9}$"
            }
        },
        {
            "name": "status",
            "display_name": "çŠ¶æ€",
            "field_type": "string",
            "db_type": "VARCHAR(20)",
            "default_value": "'active'",
            "validation_rules": {
                "enum": ["active", "inactive", "pending"]
            },
            "ui_config": {
                "widget": "select",
                "options": [
                    {"label": "æ´»è·ƒ", "value": "active"},
                    {"label": "åœç”¨", "value": "inactive"},
                    {"label": "å¾…å®¡æ ¸", "value": "pending"}
                ]
            }
        },
        {
            "name": "company",
            "display_name": "å…¬å¸",
            "field_type": "string",
            "is_required": False
        },
        {
            "name": "address",
            "display_name": "åœ°å€",
            "field_type": "text"
        },
        {
            "name": "tags",
            "display_name": "æ ‡ç­¾",
            "field_type": "json",
            "ui_config": {
                "widget": "tag-input"
            }
        }
    ]
}

# 2. åˆ›å»ºæ¨¡å‹
metadata_service = MetadataService(session)
model = await metadata_service.create_model(
    workspace_id=workspace_id,
    created_by=user_id,
    **model_data
)

print(f"Model created: {model.id}")
```

### ç¤ºä¾‹2ï¼šå‘å¸ƒæ¨¡å‹ï¼ˆåˆ›å»ºæ•°æ®åº“è¡¨ï¼‰

```python
from app.services.metadata_service import MetadataService

# 1. å‘å¸ƒæ¨¡å‹
metadata_service = MetadataService(session)
await metadata_service.publish_model(model.id)

# è¿™å°†ï¼š
# - ç”Ÿæˆ CREATE TABLE SQL
# - æ‰§è¡Œ DDL åˆ›å»ºè¡¨
# - ç”ŸæˆåŠ¨æ€ ORM æ¨¡å‹
# - ç”ŸæˆåŠ¨æ€ API è·¯ç”±
# - æ›´æ–°æ¨¡å‹çŠ¶æ€ä¸º published
```

### ç¤ºä¾‹3ï¼šä½¿ç”¨åŠ¨æ€ API

```python
import httpx

# 1. åˆ›å»ºå®¢æˆ·è®°å½•
response = await httpx.post(
    f"/api/v1/data/customer?workspace_id={workspace_id}&user_id={user_id}",
    json={
        "data": {
            "name": "å¼ ä¸‰",
            "email": "zhangsan@example.com",
            "phone": "13800138000",
            "status": "active",
            "company": "ABCå…¬å¸",
            "address": "åŒ—äº¬å¸‚æœé˜³åŒº",
            "tags": ["VIP", "é‡ç‚¹å®¢æˆ·"]
        }
    }
)
customer = response.json()
print(f"Customer created: {customer['id']}")

# 2. æŸ¥è¯¢å®¢æˆ·åˆ—è¡¨
response = await httpx.get(
    f"/api/v1/data/customer?workspace_id={workspace_id}&page=1&page_size=20"
)
result = response.json()
print(f"Total customers: {result['total']}")
print(f"Customers: {result['items']}")

# 3. æ›´æ–°å®¢æˆ·
response = await httpx.put(
    f"/api/v1/data/customer/{customer['id']}?workspace_id={workspace_id}",
    json={
        "data": {
            "status": "inactive",
            "tags": ["VIP", "é‡ç‚¹å®¢æˆ·", "å·²åœç”¨"]
        }
    }
)

# 4. åˆ é™¤å®¢æˆ·ï¼ˆè½¯åˆ é™¤ï¼‰
response = await httpx.delete(
    f"/api/v1/data/customer/{customer['id']}?workspace_id={workspace_id}"
)
```

---

## ğŸ”„ å®Œæ•´å·¥ä½œæµç¨‹

### 1. æ¨¡å‹è®¾è®¡é˜¶æ®µ

```python
# æ­¥éª¤1ï¼šåˆ›å»ºæ¨¡å‹ï¼ˆè‰ç¨¿çŠ¶æ€ï¼‰
model = await metadata_service.create_model(...)

# æ­¥éª¤2ï¼šæ·»åŠ å­—æ®µ
for field_data in fields:
    await metadata_service.add_field(model.id, field_data)

# æ­¥éª¤3ï¼šå®šä¹‰å…³ç³»
await metadata_service.add_relation(
    source_model_id=customer_model.id,
    target_model_id=order_model.id,
    relation_type="one_to_many",
    foreign_key_field="customer_id"
)

# æ­¥éª¤4ï¼šå®šä¹‰ç´¢å¼•
await metadata_service.add_index(
    model_id=model.id,
    fields=["email", "phone"],
    is_unique=True
)
```

### 2. æ¨¡å‹å‘å¸ƒé˜¶æ®µ

```python
# æ­¥éª¤1ï¼šéªŒè¯æ¨¡å‹
validation_result = await metadata_service.validate_model(model.id)
if not validation_result.is_valid:
    print(f"Validation errors: {validation_result.errors}")
    return

# æ­¥éª¤2ï¼šç”Ÿæˆ DDL
ddl_generator = DDLGenerator(session)
create_sql = await ddl_generator.generate_create_table(model.id)
print(f"Generated SQL:\n{create_sql}")

# æ­¥éª¤3ï¼šæ‰§è¡Œ DDL
await ddl_generator.execute_ddl(create_sql)

# æ­¥éª¤4ï¼šç”ŸæˆåŠ¨æ€ ORM
orm_generator = DynamicModelGenerator(session)
model_class = await orm_generator.generate_model(model.id)

# æ­¥éª¤5ï¼šç”ŸæˆåŠ¨æ€ API
api_generator = DynamicAPIGenerator()
router = api_generator.generate_crud_router(
    model_id=model.id,
    model_name=model.name
)

# æ­¥éª¤6ï¼šæ³¨å†Œè·¯ç”±åˆ° FastAPI
app.include_router(router, prefix="/api/v1")

# æ­¥éª¤7ï¼šæ›´æ–°æ¨¡å‹çŠ¶æ€
await metadata_service.publish_model(model.id)
```

### 3. æ¨¡å‹ä½¿ç”¨é˜¶æ®µ

```python
# ä½¿ç”¨åŠ¨æ€ API è¿›è¡Œ CRUD æ“ä½œ
crud_service = GenericCRUDService(session)

# åˆ›å»º
record = await crud_service.create(
    model_id=model.id,
    data={"name": "å¼ ä¸‰", "email": "zhangsan@example.com"},
    workspace_id=workspace_id,
    created_by=user_id
)

# æŸ¥è¯¢
records = await crud_service.list(
    model_id=model.id,
    workspace_id=workspace_id,
    filters={"status": "active"},
    page=1,
    page_size=20
)

# æ›´æ–°
updated = await crud_service.update(
    model_id=model.id,
    record_id=record['id'],
    data={"status": "inactive"},
    workspace_id=workspace_id
)

# åˆ é™¤
await crud_service.delete(
    model_id=model.id,
    record_id=record['id'],
    workspace_id=workspace_id
)
```

### 4. æ¨¡å‹æ›´æ–°é˜¶æ®µ

```python
# æ­¥éª¤1ï¼šä¿®æ”¹å­—æ®µ
await metadata_service.update_field(
    field_id=field.id,
    display_name="å®¢æˆ·å…¨ç§°",
    validation_rules={"min_length": 5, "max_length": 200}
)

# æ­¥éª¤2ï¼šæ·»åŠ æ–°å­—æ®µ
await metadata_service.add_field(
    model_id=model.id,
    name="industry",
    display_name="è¡Œä¸š",
    field_type="string"
)

# æ­¥éª¤3ï¼šç”Ÿæˆ ALTER TABLE
old_fields = await metadata_service.get_fields(model.id, version=1)
new_fields = await metadata_service.get_fields(model.id, version=2)
alter_sqls = await ddl_generator.generate_alter_table(
    model.id,
    old_fields,
    new_fields
)

# æ­¥éª¤4ï¼šæ‰§è¡Œ ALTER TABLE
for sql in alter_sqls:
    await ddl_generator.execute_ddl(sql)

# æ­¥éª¤5ï¼šæ¸…ç©º ORM ç¼“å­˜
orm_generator.clear_cache()

# æ­¥éª¤6ï¼šé‡æ–°ç”Ÿæˆæ¨¡å‹
model_class = await orm_generator.generate_model(model.id, use_cache=False)
```

---

## ğŸ¯ æ€»ç»“

### æ ¸å¿ƒä¼˜åŠ¿

1. **é…ç½®é©±åŠ¨**ï¼šé€šè¿‡é…ç½®å¿«é€Ÿåˆ›å»ºä¸šåŠ¡æ¨¡å‹
2. **åŠ¨æ€æ‰©å±•**ï¼šæ— éœ€ä¿®æ”¹ä»£ç å³å¯æ·»åŠ æ–°æ¨¡å‹
3. **è‡ªåŠ¨åŒ–**ï¼šè‡ªåŠ¨ç”Ÿæˆè¡¨ã€ORMã€API
4. **ç§Ÿæˆ·éš”ç¦»**ï¼šå¤©ç„¶æ”¯æŒå¤šç§Ÿæˆ·
5. **ç‰ˆæœ¬æ§åˆ¶**ï¼šæ”¯æŒæ¨¡å‹ç‰ˆæœ¬ç®¡ç†

### å®æ–½æ—¶é—´çº¿

- ç¬¬1-2å‘¨ï¼šå…ƒæ•°æ®æ¨¡å‹è®¾è®¡å’Œæ•°æ®åº“è¡¨åˆ›å»º
- ç¬¬3-4å‘¨ï¼šDDL ç”Ÿæˆå™¨å’Œ ORM ç”Ÿæˆå™¨
- ç¬¬5-6å‘¨ï¼šé€šç”¨ CRUD æœåŠ¡å’Œ API ç”Ÿæˆå™¨
- ç¬¬7-8å‘¨ï¼šå…ƒæ•°æ®ç®¡ç† API å’Œå‰ç«¯è®¾è®¡å™¨
- ç¬¬9-10å‘¨ï¼šæµ‹è¯•å’Œä¼˜åŒ–

### åç»­ä¼˜åŒ–

1. å®ç°æ›´å¤æ‚çš„æŸ¥è¯¢æ„å»ºå™¨ï¼ˆæ”¯æŒ JOINã€èšåˆç­‰ï¼‰
2. å®ç°æ•°æ®éªŒè¯å¼•æ“
3. å®ç°æ•°æ®è½¬æ¢å’Œè®¡ç®—å­—æ®µ
4. å®ç°æƒé™æ§åˆ¶å¼•æ“
5. å®ç°æ•°æ®å¯¼å…¥å¯¼å‡º
6. å®ç°æ•°æ®è¿ç§»å·¥å…·

